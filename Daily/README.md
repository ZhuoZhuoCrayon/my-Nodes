# Daily

## Notice
> 这是一个有梦想的人在他即将大三立下的一个FLAG
> 
> 计划在未来的**每一天**打卡**codeWars**或者**LeetCode**
>
> 欢迎大家监督：）我会会会加油的！

**CodeWars**
* 这是一个分语言的刷题网站，好处是可以借鉴不同语言的优秀解答
* 这个有梦想的人决定在这个网站巩固语法，养成良好的代码习惯
* 他说他会更新 `C` `C++` `Java` `Python` `JavaScript`

**LeetCode**
* 这是一个偏重于算法思维的刷题网站，唯一的缺点是C/C++不能混用
* 这个有梦想的人决定在这个网站恶补算法，为面试做好准备
* 由于解题时间可能过长，这个人决定每次随机选择一种语言求解
* 根据他的习惯一般还是`C` `C++`
```
{\ _ /}
(* . *)
 >I加油I
```
## Update Log
### CodeWars

---
### LeetCode

#### 2019.11

| Date    | Title-Link                                                   | Method       | Describe                                                     | TODO       |
| ------- | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | ---------- |
| 11.01   | [221. Maximal Square](LeetCode/20191101.md)                  | `DP`         | 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积 |            |
| 11.02   | [279. Perfect Squares](LeetCode/20191102.md)                 | `DP`         | 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少 |            |
| 11.03   | [21. Merge Two Sorted Lists](LeetCode/20191103.md)           | `List`       | 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 |            |
| 11.04   | [Prim&Kruskal](DataStructure/20191103.md)                    | `Graph`      | 最小生成树                                                   |            |
| 11.05   | [304. Range Sum Query 2D - Immutable](LeetCode/20191105.md)  | `2DDP`       | 给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 |            |
| 11.06   | [105. Construct Binary Tree from Preorder and Inorder Traversal](LeetCode/20191106.md) | `DFS`        | 根据一棵树的前序遍历与中序遍历构造二叉树。                   | 迭代求解   |
| 11.07   | [24. Swap Nodes in Pairs](LeetCode/20191107.md)              | `List`       | 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。   |            |
| 11.08   | [328. Odd Even Linked List](LeetCode/20191108.md)            | `List`       | 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起       |            |
| 11.09   | [100. Same Tree](LeetCode/20191109.md)                       | `Tree`       | 给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 |            |
| 11.10   | [200. Number of Islands](LeetCode/20191110.md)               | `BFS`        | 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。 | 并查集求解 |
| 11.11   | [61. Rotate List](LeetCode/20191111.md)                      | `List`       | 给定一个链表，旋转链表，将链表每个节点向右移动 *k* 个位置，其中 *k* 是非负数 |            |
| 11.12   | [116. Populating Next Right Pointers in Each Node](LeetCode/20191112.md) | `Tree`       | 给定一个**完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 |            |
| 11.13   | [129. Sum Root to Leaf Numbers](LeetCode/20191113.md)        | `DFS` `TREE` | 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1->2->3 代表数字 123。求根到叶子节点生成的所有数字之和 |            |
| 11.14   | [101. Symmetric Tree](LeetCode/20191114.md)                  | `Tree`       | 给定一个二叉树，检查它是否是镜像对称的                       |            |
| 11.15   | [309. Best Time to Buy and Sell Stock with Cooldown](LeetCode/20191115.md) | `DP`         | 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 |            |
| 11.16-1 | [122. Best Time to Buy and Sell Stock II](LeetCode/20191116.md) | `DP`         | 股票交易问题-交易次数不限                                    |            |
| 11.16-2 | [123. Best Time to Buy and Sell Stock III](LeetCode/20191116-2.md) | `DP`         | 股票交易问题-最多完成2笔交易                                 |            |
| 11.16-3 | [123. Best Time to Buy and Sell Stock III](LeetCode/20191116-3.md) | `DP`         | 股票交易问题-最多完成k笔交易                                 |            |
| 11.17   | [714. Best Time to Buy and Sell Stock with Transaction Fee](LeetCode/20191117.md) | `DP`         | 股票交易问题-含手续费                                        |            |
| 11.18   | [782. Remove Duplicates from Sorted List II](LeetCode/20191118.md) | `List`       | 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现* 的数字。 | bestANS    |
| 11.19   | [338. Counting Bits](LeetCode/20191119.md)                   | `DP`         | 给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。 |            |
| 11.20   | [86. Partition List](LeetCode/20191120.md)                   | `List`       | 给定一个链表和一个特定值 *x*，对链表进行分隔，使得所有小于 *x* 的节点都在大于或等于 *x* 的节点之前。 |            |
| 11.21   | [322. Coin Change](LeetCode/20191121.md)                     | `DP`         | 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 |            |
|         |                                                              |              |                                                              |            |
|         |                                                              |              |                                                              |            |
|         |                                                              |              |                                                              |            |
|         |                                                              |              |                                                              |            |
|         |                                                              |              |                                                              |            |
|         |                                                              |              |                                                              |            |

