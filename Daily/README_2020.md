# Daily

## Notice

> 这是一个有梦想的人在他即将大三立下的一个FLAG
>
> 计划在未来的**每一天**打卡**codeWars**或者**LeetCode**
>
> 欢迎大家监督：）我会会会加油的！

**CodeWars**

* 这是一个分语言的刷题网站，好处是可以借鉴不同语言的优秀解答
* 这个有梦想的人决定在这个网站巩固语法，养成良好的代码习惯
* 他说他会更新 `C` `C++` `Java` `Python` `JavaScript`

**LeetCode**

* 这是一个偏重于算法思维的刷题网站，唯一的缺点是C/C++不能混用
* 这个有梦想的人决定在这个网站恶补算法，为面试做好准备
* 由于解题时间可能过长，这个人决定每次随机选择一种语言求解
* ~~根据他的习惯一般还是`C` `C++`~~
* 最后他基本用`Java`

```
{\ _ /}
(* . *)
 >I加油I
```

## Update Log

### 2020.1

| Date  | Title-Link                                                   | Method          | Describe                                                     | TODO        |
| ----- | ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ | ----------- |
| 01.01 | [18. 4Sum](LeetCode/202001/20200101.md)                      | `Array`         | 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 |             |
| 01.02 | [31. Next Permutation](LeetCode/202001/20200102.md)          | `Array`         | 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 | review      |
| 01.03 | [39. Combination Sum](LeetCode/202001/20200103.md)           | `Array`         | 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 |             |
| 01.04 | [40. Combination Sum II](LeetCode/202001/20200104.md)        | `Array`         | 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。 |             |
| 01.05 | [48. Rotate Image](LeetCode/202001/20200105.md)              | `Matrix`        | 给定一个 n × n 的二维矩阵表示一个图像。需要原地旋转          | review      |
| 01.06 | [376. Wiggle Subsequence](LeetCode/202001/20200106.md)       | `DP`            | 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 |             |
| 01.07 | [1277. Count Square Submatrices with All Ones](LeetCode/202001/20200107.md) | `DP`            | 给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。 |             |
| 01.08 | [55. Jump Game](LeetCode/202001/20200108.md)                 | `DP`            | 给定一个非负整数数组，你最初位于数组的第一个位置             |             |
| 01.09 | [66. Plus One](LeetCode/202001/20200109.md)                  | `Array`         | 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 |             |
| 01.10 | [337. House Robber III](LeetCode/202001/20200110.md)         | `树形DP`        | 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 | review      |
| 01.11 | [416. Partition Equal Subset Sum](LeetCode/202001/20200111.md) | `01背包`        | 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 | 01背包变形  |
| 01.12 | [474. Ones and Zeroes](LeetCode/202001/20200112.md)          | `01背包`        | 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 | 01背包变形  |
| 01.13 | [494. Target Sum](LeetCode/202001/20200113.md)               | `DP`            | 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 | 01背包变形  |
| 01.14 | [523. Continuous Subarray Sum](LeetCode/202001/20200114.md)  | `DP`            | 给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。 | hashMap解法 |
| 01.15 | [576. Out of Boundary Paths](LeetCode/202001/20200115.md)    | `DP`            | 给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动 N 次。找出可以将球移出边界的路径数量。答案可能非常大，返回 结果 mod 1e9 + 7 的值。 | review      |
| 01.16 | [638. Shopping Offers](LeetCode/202001/20200116.md)          | `DFS`           | 现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。 |             |
| 01.17 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200117.md) | `贪心`          | 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造 |             |
| 01.18 | [646. Maximum Length of Pair Chain](LeetCode/202001/20200118.md) | `DP`            | 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 |             |
| 01.19 | [650.  Keys Keyboard](LeetCode/202001/20200119.md)           | `DP` `Math`     | 给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。 | `review`    |
| 01.20 | [112. Path Sum](LeetCode/202001/20200120.md)                 | `DFS`           | 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 |             |
| 01.21 | [189. Rotate Array](LeetCode/202001/20200121.md)             | `Array`         | 给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。 |             |
| 01.22 | [73. Set Matrix Zeroes](LeetCode/202001/20200122.md)         | `DFS`           | 给定一个二维网格和一个单词，找出该单词是否存在于网格中。     |             |
| 01.23 | [79. Word Search](LeetCode/202001/20200123.md)               | `Matrix`        | 给定一个 *m* x *n* 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**[原地](http://baike.baidu.com/item/原地算法)**算法 |             |
| 01.24 | [56. Merge Intervals](LeetCode/202001/20200123.md)           | `Array`         | 给出一个区间的集合，请合并所有重叠的区间。                   |             |
| 01.25 | [80. Remove Duplicates from Sorted Array II](LeetCode/202001/20200125.md) | `Array`         | 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。O(1) | 双指针      |
| 01.26 | [88. Merge Sorted Array](LeetCode/202001/20200126.md)        | `Array`         | 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 |             |
| 01.27 | [90. Subsets II](LeetCode/202001/20200127.md)                | `回溯`          | 给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。 |             |
| 01.28 | [162. Find Peak Element](LeetCode/202001/20200128.md)        | `Binary Search` | 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 |             |
| 01.29 | [111. Minimum Depth of Binary Tree](LeetCode/202001/20200129.md) | `DFS`           | 给定一个二叉树，找出其最小深度。                             |             |
| 01.30 | [257. Binary Tree Paths](LeetCode/202001/20200130.md)        | `DFS`           | 给定一个二叉树，返回所有从根节点到叶子节点的路径。           |             |
| 01.31 | [688. Knight Probability in Chessboard](LeetCode/202001/20200131.md) | `DP`            | 求移动结束后，“马” 仍留在棋盘上的概率。                      |             |

```
{\ _ /}
(* . *)
 >I完成I 1月份共完成31题
```

----



### 2020.2

| Date    | Title-Link                                                   | Method                   | Describe                                                     | TODO                 |
| ------- | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ | -------------------- |
| 02.01   | [167. Two Sum II - Input array is sorted](LeetCode/202002/20200201.md) | `二分查找`               | 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 |                      |
| 02.02   | [107. Binary Tree Level Order Traversal II](LeetCode/202002/20200202.md) | `BFS`                    | 给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） |                      |
| 02.03   | [209. Minimum Size Subarray Sum](LeetCode/202002/20200203.md) | `BS` `Two pointer`       | 给定一个含有 **n** 个正整数的数组和一个正整数 **s ，**找出该数组中满足其和 **≥ s** 的长度最小的连续子数组**。**如果不存在符合条件的连续子数组，返回 0 | 二分/滑动窗口        |
| 02.04   | [240. Search a 2D Matrix II](LeetCode/202002/20200204.md)    | `matrix` `binary search` | 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target | review               |
| 02.05   | [287. Find the Duplicate Number](LeetCode/202002/20200205.md) | `List`                   | 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 | 链表寻环             |
| 02.06   | [698. Partition to K Equal Sum Subsets](LeetCode/202002/20200206.md) | `回溯`                   | 给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。 | 经典回溯             |
| 02.07   | [718. Maximum Length of Repeated Subarray](LeetCode/202002/20200207.md) | `DP`                     | 给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。 |                      |
| 02.08   | [740. Delete and Earn](LeetCode/202002/20200208.md)          | `DP`                     | 给定一个整数数组 nums ，你可以对它进行一些操作。每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 |                      |
| 02.09   | [5. Longest Palindromic Substring](LeetCode/202002/20200209.md) | `DP`                     | 给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。 | review               |
| 02.10   | [32. Longest Valid Parentheses](LeetCode/202002/20200210.md) | `DP`                     | 给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。 | review               |
| 02.11-1 | [8.二叉树的下一个结点](剑指Offer/8-12/8.二叉树的下一个结点.md) | `Tree`                   | 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 | review               |
| 02.11-2 | [9. 用两个栈实现队列](剑指Offer/8-12/9.用两个栈实现队列.md)  | `Queue` `Stack`          | 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 |                      |
| 02.11-3 | [10. 斐波那契数列](剑指Offer/8-12/10.斐波那契数列.md)        | `DP`                     | 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 |                      |
| 02.11-4 | [11. 旋转数组的最小数字](剑指Offer/8-12/11.旋转数组的最小数字.md) | `Array` `Search`         | 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 |                      |
| 02.11-5 | [12.矩阵中的路径](剑指Offer/8-12/12.矩阵中的路径.md)         | `DFS`                    | 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径 |                      |
| 02.12-1 | [13.机器人的运动范围](剑指Offer/13-18/13.机器人的运动范围.md) | `DFS`                    | 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ |                      |
| 02.12-2 | [14. 剪绳子](剑指Offer/13-18/14.剪绳子.md)                   | `DP` `贪心`              | 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 | review               |
| 02.12-3 | [15.二进制中1的个数](剑指Offer/13-18/15.二进制中1的个数.md)  | `Bit`                    | 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 |                      |
| 02.12-4 | [16. 数值的整数次方](剑指Offer/13-18/16.数值的整数次方.md)   | `快速幂`                 | 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 |                      |
| 02.12-5 | [17.打印从1到最大的n位数](剑指Offer/13-18/17.打印从1到最大的n位数.md) | `Array`                  | 输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 |                      |
| 02.12-6 | [18.删除链表的节点](剑指Offer/13-18/18.删除链表的节点.md)    | `List`                   | 给定单向链表的头指针和一个要删除的节点的值，定义一个函数在 *O*(1) 时间内删除该节点。 |                      |
| 02.13   | [19.正则表达式匹配](剑指Offer/19-23/19.正则表达式匹配.md)    | `DP` `递归`              | 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。 | review               |
| 02.13   | [20.表示数值的字符串](剑指Offer/19-23/20.表示数值的字符串.md) | `String`                 | 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 | review               |
| 02.13   | [21.整数组顺序使奇数位于偶数前面](剑指Offer/19-23/21.调整数组顺序使奇数位于偶数前面.md) | `two points`             | 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 |                      |
| 02.13   | [22.链表中倒数第k个节点](剑指Offer/19-23/22.链表中倒数第k个节点.md) | `快慢指针`               | 输入一个链表，输出该链表中倒数第k个节点。                    |                      |
| 02.13   | [23.链表中环的入口结点](剑指Offer/19-23/23.链表中环的入口结点.md) | `List`                   | 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 |                      |
| 02.14   | [24.反转链表](剑指Offer/24-28/24.反转链表.md)                | `List`                   | 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 |                      |
| 02.14   | [25.合并两个排序的链表](剑指Offer/24-28/25.合并两个排序的链表.md) | `List`                   | 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 | 递归解法             |
| 02.14   | [26.树的子结构](剑指Offer/24-28/26.树的子结构.md)            | `Tree`                   | 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) |                      |
| 02.14   | [27.二叉树的镜像](剑指Offer/24-28/27.二叉树的镜像.md)        | `tree`                   | 请完成一个函数，输入一个二叉树，该函数输出它的镜像。         |                      |
| 02.14   | [28.对称的二叉树](剑指Offer/24-28/28.对称的二叉树.md)        | `Tree`                   | 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 |                      |
| 02.15   | [29.顺时针打印矩阵](剑指Offer/29-33/29.顺时针打印矩阵.md)    |                          | 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 |                      |
| 02.15   | [30.包含min函数的栈](剑指Offer/29-33/30.包含min函数的栈.md)  | `Stack`                  | 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 | review               |
| 02.15   | [31.栈的压入弹出序列](剑指Offer/29-33/31.栈的压入弹出序列.md) | `Stack`                  | 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 | 队列模拟             |
| 02.15   | [32-I.从上到下打印二叉树](剑指Offer/29-33/32-I.从上到下打印二叉树.md) | `BFS` `Tree`             | 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 |                      |
| 02.15   | [32-II.从上到下打印二叉树](剑指Offer/29-33/32-II.从上到下打印二叉树.md) | `Tree` `bfs`             | 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 |                      |
| 02.15   | [32-III.从上到下打印二叉树](剑指Offer/29-33/32-III.从上到下打印二叉树.md) | `BFS` `Tree`             | 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 |                      |
| 02.15   | [33. 二叉搜索树的后序遍历序列](剑指Offer/29-33/33.二叉搜索树的后序遍历序列.md) | `BST`                    | 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。 |                      |
| 02.16   | [34.二叉树中和为某一值的路径](剑指Offer/34-36/34.二叉树中和为某一值的路径.md) | `Tree` `DFS`             | 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 |                      |
| 02.16   | [35.复杂链表的复制](剑指Offer/34-36/35.复杂链表的复制.md)    | `DFS` `LIST`             | 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null |                      |
| 02.16   | [36.二叉搜索树与双向链表](剑指Offer/34-36/36.二叉搜索树与双向链表.md) | `BST`                    | 将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 | 前序/后序线索化      |
| 02.17   | [37.序列化二叉树](剑指Offer/37-39/37.序列化二叉树.md)        |                          | 请实现两个函数，分别用来序列化和反序列化二叉树。             | 补前序中后等         |
| 02.17   | [38.字符串的排列](剑指Offer/37-39/38.字符串的排列.md)        |                          | 输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 | 交换法               |
| 02.17   | [39.数组中出现次数超过一半的数字](剑指Offer/37-39/39.数组中出现次数超过一半的数字.md) |                          | 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 | 神奇的解法           |
| 02.18   | [40.最小的k个数](剑指Offer/40-42/40.最小的k个数.md)          | `heap`                   | 输入整数数组 `arr` ，找出其中最小的 `k` 个数                 | 堆实现               |
| 02.18   | [41.数据流中的中位数](剑指Offer/40-42/41.数据流中的中位数.md) | `heap`                   | 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 | 堆的维护             |
| 02.18   | [42.连续子数组的最大和](剑指Offer/40-42/42.连续子数组的最大和.md) | `DP`                     | 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 |                      |
| 02.19   | [43.1～n整数中1出现的次数](剑指Offer/43-45/43.1～n整数中1出现的次数.md) | `Math`                   | 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。  | 规律题，记得回来看看 |
| 02.19   | [43.1～n整数中1出现的次数](剑指Offer/43-45/43.1～n整数中1出现的次数.md) | `math`                   | 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 | 同上                 |
| 02.19   | [45.把数组排成最小的数](剑指Offer/43-45/45.把数组排成最小的数.md) | `String` `greedy`        | 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 | 不等长字符串相加排序 |
| 02.20   | [46. 把数字翻译成字符串](剑指Offer/46-48/46.把数字翻译成字符串.md) | `DP`                     | 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 |                      |
| 02.20   | [47.礼物的最大价值](剑指Offer/46-48/47.礼物的最大价值.md)    | `DP`                     | 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ |                      |
| 02.20   | [48.最长不含重复字符的子字符串](剑指Offer/46-48/48.最长不含重复字符的子字符串.md) |                          | 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 | 滑动窗口             |
| 02.21   | [49.丑数](剑指Offer/49-52/49.丑数.md)                        | `dp`                     | 我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 | 三指针：第二次不会   |
| 02.21   | [50.第一个只出现一次的字符](剑指Offer/49-52/50.第一个只出现一次的字符.md) |                          | 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 |                      |
| 02.21   | [51.数组中的逆序对](剑指Offer/49-52/51.数组中的逆序对.md)    | `分治`                   | 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 | 分治法：重点         |
| 02.21   | [52.两个链表的第一个公共节点](剑指Offer/49-52/52.两个链表的第一个公共节点.md) | `List`                   | 输入两个链表，找出它们的第一个公共节点。                     | 交替遍历             |
| 02.22   | [53-I.在排序数组中查找数字I](剑指Offer/53-55/53-I.在排序数组中查找数字I.md) | `二分`                   | 统计一个数字在排序数组中出现的次数。                         | 二分边界             |
| 02.22   | [53-II.0～n-1中缺失的数字](剑指Offer/53-55/53-II.0～n-1中缺失的数字.md) | `BS`                     | 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 |                      |
| 02.22   | [54.二叉搜索树的第k大节点](剑指Offer/53-55/54.二叉搜索树的第k大节点.md) | `BST`                    | 给定一棵二叉搜索树，请找出其中第k大的节点。                  |                      |
| 02.22   | [55-I.二叉树的深度](剑指Offer/53-55/55-I.二叉树的深度.md)    | `Tree`                   | 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 |                      |
| 02.22   | [55-II.平衡二叉树](剑指Offer/53-55/55-II.平衡二叉树.md)      | `Tree`                   | 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 |                      |
| 02.23   | [56-I.数组中数字出现的次数](剑指Offer/56-58/56-I.数组中数字出现的次数.md) | `bit`                    | 一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 | review               |
| 02.23   | [56-II.数组中数字出现的次数II](剑指Offer/56-58/56-II.数组中数字出现的次数II.md) | `bit`                    | 在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 | O(n)解法             |
| 02.23   | [57-II.和为s的连续正数序列](剑指Offer/56-58/57-II.和为s的连续正数序列.md) | `sliding window`         | 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 | 滑动窗口             |
| 02.23   | [57.和为s的两个数字](剑指Offer/56-58/57.和为s的两个数字.md)  | `two pointer`            | 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 | 双指针               |
| 02.23   | [58-I.翻转单词顺序](剑指Offer/56-58/58-I.翻转单词顺序.md)    | `String`                 | 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。 |                      |
| 02.23   | [58-II.左旋转字符串](剑指Offer/56-58/58-II.左旋转字符串.md)  |                          | 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。 |                      |
| 02.24   | [59-I.滑动窗口的最大值](剑指Offer/59-60/59-I.滑动窗口的最大值.md) | `Queue`                  | 给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。 | 单调队列维护         |
| 02.24   | [59-II.队列的最大值](剑指Offer/59-60/59-II.队列的最大值.md)  | `Queue`                  | 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。 | 单调队列维护         |
| 02.24   | [60.n个骰子的点数](剑指Offer/59-60/60.n个骰子的点数.md)      | `DP`                     | 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 | 概率组合             |
| 02.25   | [61.扑克牌中的顺子](剑指Offer/61-65/61.扑克牌中的顺子.md)    |                          | 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 |                      |
| 02.25   | [62.圆圈中最后剩下的数字](剑指Offer/61-65/62.圆圈中最后剩下的数字.md) |                          | 0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 | 递推推导             |
| 02.25   | [63.股票的最大利润](剑指Offer/61-65/63.股票的最大利润.md)    |                          | 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ |                      |
| 02.25   | [64.求1+2+…+n](剑指Offer/61-65/64.求1+2+…+n.md)              |                          | 求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 | 逻辑运算短路         |
| 02.25   | [65.不用加减乘除做加法](剑指Offer/61-65/65.不用加减乘除做加法.md) |                          | 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 | 异或求和             |
| 02.26   | [66.构建乘积数组](剑指Offer/66-68/66.构建乘积数组.md)        | `Array`                  | 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 |                      |
| 02.26   | [67.把字符串转换成整数](剑指Offer/66-68/67.把字符串转换成整数.md) | `String`                 | 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 | 溢出判定             |
| 02.26   | [68-I.二叉搜索树的最近公共祖先](剑指Offer/66-68/68-I.二叉搜索树的最近公共祖先.md) | `Tree`                   | 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。   | review               |
| 02.26   | [68-II.二叉树的最近公共祖先](剑指Offer/66-68/68-II.二叉树的最近公共祖先.md) | `Tree`                   | 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。       | review               |
| 02.27   | [3.数组中重复的数字](剑指Offer/3-10/3.数组中重复的数字.md)   |                          | 找出数组中重复的数字。                                       |                      |
| 02.27   | [4.二维数组中的查找](剑指Offer/3-10/4.二维数组中的查找.md)   |                          | 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 |                      |
| 02.27   | [5. 替换空格](剑指Offer/3-10/5.替换空格.md)                  |                          | 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。       |                      |
| 02.27   | [6.从尾到头打印链表](剑指Offer/3-10/6.从尾到头打印链表.md)   |                          | 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 |                      |
| 02.27   | [7.重建二叉树](剑指Offer/3-10/7.重建二叉树.md)               |                          | 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 |                      |
| 02.27   | [9.用两个栈实现队列](剑指Offer/3-10/9.用两个栈实现队列.md)   |                          | 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) |                      |
| 02.27   | [10-I.斐波那契数列](剑指Offer/3-10/10-I.斐波那契数列.md)     |                          | 斐波那契数列                                                 |                      |
| 02.27   | [10-II.青蛙跳台阶问题](剑指Offer/3-10/10-II.青蛙跳台阶问题.md) |                          | 斐波那契数列                                                 |                      |
| 02.28   | [01.01.判定字符是否唯一](程序猿面试金典/1-3/01.01.判定字符是否唯一.md) |                          | 实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。    | 位运算               |
| 02.28   | [01.02.判定是否互为字符重排](程序猿面试金典/1-3/01.02.判定是否互为字符重排.md) |                          | 给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。 |                      |
| 02.28   | [01.03.URL化](程序猿面试金典/1-3/01.03.URL化.md)             |                          | URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） |                      |
| 02.29   | [01.04.回文排列](程序猿面试金典/4-5/01.04.回文排列.md)       |                          | 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。 |                      |
| 02.29   | [01.05.一次编辑](程序猿面试金典/4-5/01.05.一次编辑.md)       |                          | 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。 | 双指针               |
| 02.29   | [牛牛找工作](大厂专题/网易/2019实习招聘/牛牛找工作.md.md)    |                          | 为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 | 贪心                 |
|         |                                                              |                          |                                                              |                      |
|         |                                                              |                          |                                                              |                      |
|         |                                                              |                          |                                                              |                      |
|         |                                                              |                          |                                                              |                      |

### 2020.3

| Date  | Title-Link                                                   | Method          | Describe                                                     | TODO           |
| ----- | ------------------------------------------------------------ | --------------- | ------------------------------------------------------------ | -------------- |
| 03.01 | [225. 用队列实现栈](LeetCode/202003/225.用队列实现栈.md)     | `queue` `stack` |                                                              |                |
| 03.01 | [01.06.字符串压缩](程序猿面试金典/6-10/01.06.字符串压缩.md)  |                 | 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。 |                |
| 03.02 | [01.07.旋转矩阵](程序猿面试金典/6-10/01.07.旋转矩阵.md)      |                 | 给定一幅由N × N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。 | 两次交换       |
| 03.03 | [01.09.字符串轮转](程序猿面试金典/6-10/01.09.字符串轮转.md)  | `string`        | 字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。 |                |
| 03.04 | [994.腐烂的橘子](LeetCode/202003/994.腐烂的橘子.md)          | `bfs`           | 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 |                |
| 03.04 | [02.01.移除重复节点](程序猿面试金典/6-10/02.01.移除重复节点.md) | `List`          | 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 | review         |
| 03.04 | [02.03.删除中间节点](程序猿面试金典/6-10/02.03.删除中间节点.md) | `List`          | 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。 |                |
| 03.05 | [02.04.分割链表](程序猿面试金典/11-15/02.04.分割链表.md)     | `List`          | 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。 |                |
| 03.05 | [02.05.链表求和](程序猿面试金典/11-15/02.05.链表求和.md)     | `List`          | 给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。 |                |
| 03.05 | [02.06.回文链表](程序猿面试金典/11-15/02.06.回文链表.md)     | `List`          | 编写一个函数，检查输入的链表是否是回文的。                   |                |
| 03.06 | [03.01.三合一](程序猿面试金典/11-15/03.01.三合一.md)         | `stack`         | 三合一。描述如何只用一个数组来实现三个栈。                   |                |
| 03.07 | [03.03.堆盘子](程序猿面试金典/16-20/03.03.堆盘子.md)         | `stack`         | 堆盘子。                                                     |                |
| 03.08 | [03.05.栈排序](程序猿面试金典/16-20/03.05.栈排序.md)         | `stack`         | 栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。 | review         |
| 03.08 | [03.06.动物收容所](程序猿面试金典/16-20/03.06.动物收容所.md) | `array`         | 动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。 |                |
| 03.08 | [04.01.节点间通路](程序猿面试金典/16-20/04.01.节点间通路.md) | `dfs` `bfs`     | 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。 |                |
| 03.09 | [04.05.合法二叉搜索树](程序猿面试金典/16-20/04.05.合法二叉搜索树.md) | `bst`           | 实现一个函数，检查一棵二叉树是否为二叉搜索树。               | review         |
| 3.10  | [1013.将数组分成和相等的三个部分](LeetCode/202003/1013.将数组分成和相等的三个部分.md) | `Array`         | 给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。 | review         |
| 3.11  | [543.二叉树的直径](LeetCode/202003/543.二叉树的直径.md)      | `Tree`          | 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 | 羞耻，没有思路 |
| 3.12  | [1071.字符串的最大公因子](LeetCode/202003/1071.字符串的最大公因子.md) | `Math`          | 对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2. | 最大公约数     |
| 3.13  | [04.06.后继者](程序猿面试金典/21-25/04.06.后继者.md)         | `tree`          | 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回`null`。 | review         |
| 3.14  | [14.最长公共前缀](LeetCode/202003/14.最长公共前缀.md)        | `string`        | 编写一个函数来查找字符串数组中的最长公共前缀如果不存在公共前缀，返回空字符串 `""`。 |                |
| 3.15  | [695.岛屿的最大面积](LeetCode/202003/695.岛屿的最大面积.md)  | `dfs`           | 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) |                |
| 3.15  | [25.K 个一组翻转链表](LeetCode/202003/25.K个一组翻转链表.md) | `List`          | 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 |                |
|       |                                                              |                 |                                                              |                |
|       |                                                              |                 |                                                              |                |
|       |                                                              |                 |                                                              |                |
|       |                                                              |                 |                                                              |                |
|       |                                                              |                 |                                                              |                |
|       |                                                              |                 |                                                              |                |

